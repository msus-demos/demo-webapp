parameters:
  azureSubscription:
  acrName:
  dockerFullyQualifiedImageName:
  dockerTag:

jobs:
- job: BuildAndTest
  displayName: Build and Test
  pool:
    vmImage: 'Ubuntu-16.04'

  variables:
    dockerImageAndTag: ${{ parameters['dockerFullyQualifiedImageName'] }}:${{ parameters['dockerTag'] }}
    latestBaseTag: ${{ parameters['dockerFullyQualifiedImageName'] }}:base-latest
    latestTestTag: ${{ parameters['dockerFullyQualifiedImageName'] }}:test-latest

  steps:
  - task: AzureCLI@1
    displayName: Log in to ACR, pull and build test image
    inputs:
      azureSubscription: ${{ parameters['azureSubscription'] }}
      scriptLocation: inlineScript
      inlineScript: |
        # Fail on errors, output every command and result to the log
        set -e -x

        # Log in to the Azure Container Registry
        az acr login -n ${{ parameters['acrName'] }}

  - script: | 
      # Fail on errors, output every command and result to the log
      set -e -x

      # Pull the latest Base image _if_ it's available, we'll use that as a cache later
      docker pull $(latestBaseTag) || true

      # Navigate to our app directory
      cd $(System.DefaultWorkingDirectory)/src/demo-ruby-webapp/

      # Build the Base stage and tag it as the latest Base image
      docker build \
        -t $(latestBaseTag) \
        --target base \
        --cache-from $(latestBaseTag)
        .
    displayName: Build and cache intermediate images


  - script: | 
      # Fail on errors, output every command and result to the log
      set -e -x

      # Navigate to our app directory
      cd $(System.DefaultWorkingDirectory)/src/demo-ruby-webapp/

      # Pull the latest Test image _if_ it's available, we'll use that as a cache later
      docker pull $(latestTestTag) || true

      # Build the Test stage and tag it as the latest Base image
      docker build \
        -t $(latestTestTag) \
        --target test \
        --cache-from $(latestBaseTag) \
        --cache-from $(latestTestTag) \
        .

      # Run RSpec tests
      docker run \
        -e 'RAILS_ENV=test' \
        $(latestTestTag) \
        bundle exec rspec -format RspecJunitFormatter --out result.xml

      # Push latest test image to ACR as test-latest
      docker push $(latestTestTag)
    displayName: Run RSpec Tests
    condition: eq(variables['Build.Reason'], 'PullRequest')

  - script: |
      # Fail on errors, output every command and result to the log
      set -e -x

      # Navigate to our app directory
      cd $(System.DefaultWorkingDirectory)/src/demo-ruby-webapp/

      docker build \
        -t $(dockerImageAndTag) \
        --target release \
        --cache-from $(latestBaseTag) \
        .

      # Build the Release Docker Stage, using the latest test image as a layer cache
      docker build \
        -t $(dockerImageAndTag) \
        --target release \
        --cache-from $(latestBaseTag) \
        .

      # Push the Release image to ACR
      docker push $(dockerImageAndTag)

      # Push the Base image to ACR as base-latest
      docker push $(latestBaseTag)
    displayName: Build and push the final container images
    condition: ne(variables['Build.Reason'], 'PullRequest')
